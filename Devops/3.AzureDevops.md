### Understanding "Build Once, Deploy Many"
In normal flow we do separate `npm run rollup` for dev and prod stages.

That’s fine, but it creates:
- **Inconsistency risk**: Dev and prod might not be the same build.
- **Wasted compute time**: Building twice.
- **Audit gap**: Hard to trace what exact artifact went to prod.

✅ So the rule is: \
You build once in the pipeline → store it as an immutable artifact → then all deployments (dev, prod, hotfix) use that same build.

For achieving this in Azure, we have pipeline artifacts. 
- After the Build process succeeds, it stores the build output in the pipeline artifact.
- The Dev stage will take this artifact, and deploy to the Dev environment.
- On approval, the prod stage will take the same artifact and deploy to the prod environment.
- The below is an Azure Yaml script for achieving the same (This is a perfect example of Build Once, Deploy Many philosophy)
### Example: Build Once, Deploy Many in Azure YAML
```yml
trigger:
    branches:
        include:
            - main

pr:
    branches:
        include:
            - main

pool:
    name: "Default" # This is the local agent I have running in my mac machine.

stages:
    - stage: Build
      displayName: "Build Stage"
      # The stage runs on PR to main, and on merge to main
      condition: or(eq(variables['Build.Reason'], 'PullRequest'), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      jobs:
          - job: BuildJob
            steps:
                - task: NodeTool@0
                  inputs:
                      versionSpec: "18.x"
                  displayName: "Use Node.js 18"

                - script: |
                      npm ci
                      npm run lint
                      npm run build
                  displayName: "Install, Lint & Build"

                  # The task stores the build output in the pipeline artifact
                - task: PublishBuildArtifacts@1
                  inputs:
                      pathToPublish: "dist"
                      artifactName: "drop"
                      publishLocation: "Container" # stored in Azure Pipelines
                  displayName: "Publish build output as artifact"

    - stage: Dev
      displayName: "Deploy to Dev Feed"
      # Runs when PR is merged to main, and Build stage is succeeded.
      condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/main'))
      jobs:
          - job: DevDeploy
            steps:
                - download: current
                  artifact: drop
                  displayName: "Download Build Artifact"

                  # The script is to create a package.json, and .npmrc file in the downloaded drop artifact.
                  # The drop folder contains the build output -> dist/ from the npm run build output.
                  #
                  # The registry in .npmrc determines to which feed the package should be published.
                  # We also have a FEED_PAT env var, which is a Personal Access Token with necessary permissions.
                  # This PAT is required as we are using a Local pool.
                  # If we where using an Azure Cloud agent, we could have directly used $SYSTEM_ACCESSTOKEN in place of FEED_PAT
                  #
                  # Note that there is a npmAuthenticate task from Azure so as to auth the added .npmrc file just in case.
                  # - task: npmAuthenticate@0
                  #   inputs:
                  #       workingFile: $(Pipeline.Workspace)/drop/.npmrc
                  #   displayName: "Auth .npmrc"
                - script: |
                      cd $(Pipeline.Workspace)/drop

                      echo "Creating package.json file"

                      cp $(Pipeline.Workspace)/s/package.json ./package.json
                      node -e "
                        const fs = require('fs');
                        const pkg = JSON.parse(fs.readFileSync('package.json'));
                        delete pkg.devDependencies;
                        pkg.main = 'index.cjs.js';
                        pkg.module = 'index.esm.js';
                        pkg.types = 'index.d.ts';
                        fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
                      "

                      echo "Creating .npmrc file"

                      echo "registry=https://pkgs.dev.azure.com/imuhammadats/devops-test/_packaging/component-lib-dev/npm/registry/" > .npmrc
                      echo "//pkgs.dev.azure.com/imuhammadats/devops-test/_packaging/component-lib-dev/npm/registry/:_authToken=$(FEED_PAT)" >> .npmrc

                      cat .npmrc
                  displayName: "Create package.json and .npmrc file"
                  env:
                      FEED_PAT: $(FEED_PAT)

                - script: |
                      cd $(Pipeline.Workspace)/drop
                      npm publish
                  displayName: "Publish to Dev Feed"

    - stage: Prod
      dependsOn: Dev
      # Only runs when the Dev stage succeeds.
      condition: succeeded()
      jobs:
            # The Job is a deployment. Now we can specify the environment for the deployment.
            # This is done such that we can have a track of all the deployments done in the environment from the environment tab in Azure Devops.
            # Also this can be used to setup Approvals before running the deployment job. The approver can accept or reject the job.
            # Reference: https://samlearnsazure.blog/2020/02/05/approvals-in-environments/
          - deployment: ProdDeploy
            displayName: "Deploy to Prod Feed"
            environment: Production
            strategy:
              runOnce:
                deploy:
                  steps:
                      - download: current
                        artifact: drop
                        displayName: "Download Build Artifact"

                      - script: |
                            cd $(Pipeline.Workspace)/drop

                            echo "Creating package.json file"

                            cp $(Pipeline.Workspace)/s/package.json ./package.json
                            node -e "
                              const fs = require('fs');
                              const pkg = JSON.parse(fs.readFileSync('package.json'));
                              delete pkg.devDependencies;
                              pkg.main = 'index.cjs.js';
                              pkg.module = 'index.esm.js';
                              pkg.types = 'index.d.ts';
                              fs.writeFileSync('package.json', JSON.stringify(pkg, null, 2));
                            "

                            echo "Creating .npmrc file"

                            echo "registry=https://pkgs.dev.azure.com/imuhammadats/_packaging/component-lib-prod/npm/registry/" > .npmrc
                            echo "//pkgs.dev.azure.com/imuhammadats/_packaging/component-lib-prod/npm/registry/:_authToken=$(FEED_PAT)" >> .npmrc

                            cat .npmrc
                        displayName: "Create package.json and .npmrc file"
                        env:
                            FEED_PAT: $(FEED_PAT)

                      - script: |
                            cd $(Pipeline.Workspace)/drop
                            npm publish
                        displayName: "Publish to Prod Feed"
```
### Limitations of the Above Approach
- The drawback for this pipeline is this might result in many stuck Production stages.
- All dev release is not meant for production. Many might be for internal testing and usages.
- So there might be multiple Dev releases but fewer Prod releases.

## Ideal CD Flow Scenarios

### So what can be the ideal CD flow?
- This actually depends on the Project and Organization needs.

#### CASE: For Package release (Component Library) Scenario
**The Requirement:**
- The Project will be open sourced inside the organization, so CI is important for each PR. 
- There will be continous releases for Dev.
- There might be quick patch releases required for Prod releases if some production bugs are reported.
- The version must be bumped in the `package.json`.

**Branching Strategy and Release Flow:**
- master -> dev -> task-branch
- Contributors raise PR from their `task-branch` to the `dev` branch. The CI will run on each PR. This will validate the Build and ensures proper test-coverage and SonarQube validations to ensure code standards.
- The maintainer raise a PR to bump the `package.json` version to the next release version.
- The maintainer triggers the Dev release pipeline to publish package to the Azure Dev Feed.
- On Dev is stable and release ready, a PR is raised to dev with updated Changelogs and Release Notes.
- The dev to master PR is raised by the maintainer.
- After merge, the pipeline is triggered for Prod release from `master` and package is published to the Azure Prod Feed.
- If any production bug is spotted, which requires immediate patch release, a bugfix PR is raised to master directly, and merged and Prod release pipeline is triggered. \
For this flow, we need seperate pipelines for Dev and Prod releases. Here Build once, Deploy many philosophy doesn't work, which is fine in this case.

**Versioning:**
- Semantic versioning is preferred: `MAJOR.MINOR.PATCH`
- For dev releases: <Version>-alpha.<BuildNumber>. Eg: `1.3.2-alpha.0`
- For prod releases: <Version> without any alpha, beta tags. Eg: `1.3.2`
- For dev releases build-number can be the timestamp. We can use yml script to append alpha with current timestamp. This will ensure unique version build numbers.

### Storing both Dev and Prod release in a single feed.
- This is something that Azure makes it difficult to do compared to the public npm registry.
- In public registry, there is a concept of tags. We can tag a particular version with alpha, beta, latest, or any other preferred tags.
#### Concept of Tags
In npm, a tag is simply a label that points to a specific version of a package. \
When you publish a package, npm automatically assigns a tag to it — by default, this tag is latest.
```bash
# Publishes the package and tags it as latest.
npm publish

# Gets the version associated with the latest tag.
npm install your-package

# Publishing with a custom tag
npm publish --tag beta

# Gets the version associated with the custom tag.
npm install your-package@beta

## Changing tags later
# You can change which version a tag points to using:
npm dist-tag add your-package@1.2.3 latest
# This means: “make latest point to version 1.2.3.”

# Remove tag
npm dist-tag rm your-package beta

# See existing tags:
npm dist-tag ls your-package
```
#### In context of Azure Feed
- In Azure Feed, there is concept of Views.
- By default all published artifact will be a part of `@Local` View. This is the Default view in Azure Artifact feed.
- We can introduce more views in the field, eg: `@PreRelease`, `@Release`
- Later we can promote packages from Local -> PreRelease -> Release.
- To get package from a specific view, update your .npmrc as:
  ```bash
  # This will give Release versions from the feed.
  registry=https://pkgs.dev.azure.com/<organization>/<project>/_packaging/<feed-name>@Release/npm/registry/
  ```
- Publish this registry address to the consumers so that the consumers will only get the Prod release versions in their project.
- For internal testing, the developers can use the registry with @PreRelease view tag in the .npmrc
